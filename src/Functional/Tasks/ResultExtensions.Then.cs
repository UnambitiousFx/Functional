// <auto-generated>
//     This file was generated by valuetask2task.sh.
//     Do not modify manually. Changes may be overwritten.
// </auto-generated>

#nullable enable

namespace UnambitiousFx.Functional.Tasks;

public static partial class ResultExtensions
{
    /// <param name="result">The result instance.</param>
    /// <typeparam name="T1">Value type 1.</typeparam>
    extension<T1>(Result<T1> result) where T1 : notnull
    {
        /// <summary>
        ///     Async Then chaining an async transformation that returns a Result of the same type.
        /// </summary>
        /// <param name="then">The async transformation function.</param>
        /// <param name="copyReasonsAndMetadata">Whether to copy reasons and metadata from original result.</param>
        /// <returns>A task with the new result.</returns>
        public async Task<Result<T1>> ThenAsync(Func<T1, Task<Result<T1>>> then,
            bool copyReasonsAndMetadata = true)
        {
            if (!result.TryGet(out T1? value)) return result;

            var response = await then(value).ConfigureAwait(false);
            if (copyReasonsAndMetadata) response = response.WithMetadata(result.Metadata);

            return response;
        }

        /// <summary>
        ///     Asynchronously applies a transformation function to a successful result
        ///     that returns a new result of the same type, while optionally copying metadata and reasons.
        /// </summary>
        /// <param name="then">The asynchronous transformation function to apply.</param>
        /// <param name="copyReasonsAndMetadata">
        ///     Indicates whether to copy reasons and metadata from the original result to the new result.
        /// </param>
        /// <returns>
        ///     A task representing the asynchronous operation, resulting in the new result instance.
        /// </returns>
        public async Task<Result<T1>> ThenAsync(Func<T1, Task<Result>> then,
            bool copyReasonsAndMetadata = true)
        {
            if (!result.TryGet(out T1? value)) return result;

            var thenResult = await then(value);
            if (thenResult.TryGet(out var error)) return result;
            var failResult = Result.Failure<T1>(error);
            return copyReasonsAndMetadata ? failResult.WithMetadata(result.Metadata) : failResult;
        }
    }

    /// <param name="awaitableResult">The awaitable result instance.</param>
    /// <typeparam name="TValue">Value type 1.</typeparam>
    extension<TValue>(Task<Result<TValue>> awaitableResult) where TValue : notnull
    {
        /// <summary>
        ///     Async Then awaiting result then chaining a sync transformation.
        /// </summary>
        /// <param name="then">The transformation function.</param>
        /// <param name="copyReasonsAndMetadata">Whether to copy reasons and metadata from original result.</param>
        /// <returns>A task with the new result.</returns>
        public async Task<Result<TValue>> ThenAsync(Func<TValue, Result<TValue>> then, bool copyReasonsAndMetadata = true)
        {
            var result = await awaitableResult.ConfigureAwait(false);
            return result.Then(then, copyReasonsAndMetadata);
        }


        /// <summary>
        /// Asynchronously chains a transformation function that returns a non-generic result.
        /// </summary>
        /// <param name="then">The transformation function to apply on a successful result.</param>
        /// <param name="copyReasonsAndMetadata">Specifies whether to copy reasons and metadata from the original result.</param>
        /// <returns>A task containing the transformed result.</returns>
        public async Task<Result<TValue>> ThenAsync(
            Func<TValue, Result> then,
            bool copyReasonsAndMetadata = true)
        {
            var result = await awaitableResult.ConfigureAwait(false);
            return result.Then(then, copyReasonsAndMetadata);
        }

        /// <summary>
        /// Asynchronously applies a transformation function to a result of type <typeparamref name="TValue"/> and returns a new
        /// result, possibly with reasons and metadata copied from the original result.
        /// </summary>
        /// <param name="then">The transformation function that is asynchronously applied to the value of the result.</param>
        /// <param name="copyReasonsAndMetadata">Specifies whether to copy reasons and metadata from the original result.</param>
        /// <returns>A task that represents the asynchronous operation, containing the new result.</returns>
        public async Task<Result<TValue>> ThenAsync(
            Func<TValue, Task<Result>> then,
            bool copyReasonsAndMetadata = true)
        {
            var result = await awaitableResult.ConfigureAwait(false);
            return await result.ThenAsync(then, copyReasonsAndMetadata).ConfigureAwait(false);
        }

        /// <summary>
        ///     Async Then awaiting result then chaining an async transformation.
        /// </summary>
        /// <param name="then">The async transformation function.</param>
        /// <param name="copyReasonsAndMetadata">Whether to copy reasons and metadata from original result.</param>
        /// <returns>A task with the new result.</returns>
        public async Task<Result<TValue>> ThenAsync(Func<TValue, Task<Result<TValue>>> then,
            bool copyReasonsAndMetadata = true)
        {
            var result = await awaitableResult.ConfigureAwait(false);
            return await result.ThenAsync(then, copyReasonsAndMetadata).ConfigureAwait(false);
        }
    }
}